package io.github.belgif.rest.guide.validator.rules.oas;

import io.github.belgif.rest.guide.validator.core.ViolationReport;
global io.github.belgif.rest.guide.validator.core.ViolationReport oas;
import org.eclipse.microprofile.openapi.models.media.Discriminator;
import io.github.belgif.rest.guide.validator.core.model.SchemaDefinition;
import io.github.belgif.rest.guide.validator.core.ViolationLevel;
import io.github.belgif.rest.guide.validator.core.ApiFunctions;
import io.github.belgif.rest.guide.validator.core.parser.Parser.ParserResult;
global io.github.belgif.rest.guide.validator.core.parser.Parser.ParserResult parserResult;
import java.util.List;
import java.util.Map;
import org.eclipse.microprofile.openapi.models.media.Schema;
import org.eclipse.microprofile.openapi.models.media.Schema.SchemaType;
import java.util.HashMap;
import java.util.Collections;
import java.util.ArrayList;
import java.util.Set;
import java.util.stream.Collectors
import java.util.HashSet;

declare AllOfTypes
    valid : boolean
    types : Set<SchemaType>
end

function void violationDiscriminatorShouldContainMapping(ViolationReport oas, SchemaDefinition schema){
    oas.addViolation("[sch-allof]",
    "Discriminator does not have an explicit mapping of discriminator values to schemas.", null, schema, ViolationLevel.RECOMMENDED);
}

function void violationAllOfSubSchemasShouldNotDeclareTheSameProperties(ViolationReport oas, SchemaDefinition schema, String specificErrors) {
    oas.addViolation("[sch-allof]",
    "Subschemas in an allOf SHOULD NOT declare the same properties, because this will lead to problems for code generation tools.", specificErrors, schema, ViolationLevel.RECOMMENDED);
}

function void violationAllOfSubSchemasShouldNotHaveMultipleTypes(ViolationReport oas, SchemaDefinition schema, Set<SchemaType> types) {
    String typeOutput = types.stream().map(SchemaType::toString).collect(Collectors.joining(", ")).toString();
    oas.addViolation("[sch-allof]",
    "Subschemas in an allOf MUST be of the same schemaType.", "Multiple schemaTypes were found: <<" + typeOutput + ">>", schema);
}

function String parseErrorStringForDoubleProperties(Map<String, List<String>> doubleProperties) {
    StringBuilder stringBuilder = new StringBuilder();
    for (Map.Entry<String, List<String>> doubleProperty : doubleProperties.entrySet()) {
      stringBuilder.append("Property <<").append(doubleProperty.getKey()).append(">> used in:\n");
      for (String pointer : doubleProperty.getValue()) {
        stringBuilder.append("\t").append(pointer).append("\n");
      }
    }
    return stringBuilder.toString();
}

function Map getDoubleProperties(Schema schema, ParserResult parserResult) {
  Map<String, List<String>> doubleProperties = new HashMap<>();
  for (Schema subSchema : schema.getAllOf()) {
    ApiFunctions.getRecursiveProperties(subSchema, parserResult).forEach((key, value) -> {
      StringBuilder pointerBuilder = new StringBuilder();
      pointerBuilder.append(parserResult.resolve(subSchema).getPrintableJsonPointer());
      if (subSchema != value) {
        pointerBuilder.append(" (via <<").append(parserResult.resolve(value).getPrintableJsonPointer()).append(">>)");
      }
      if (doubleProperties.containsKey(key)) {
        doubleProperties.get(key).add(pointerBuilder.toString());
      } else {
        doubleProperties.put(key, new ArrayList<>(Collections.singletonList(pointerBuilder.toString())));
      }
    });
  }
  return doubleProperties.entrySet().stream()
    .filter(e -> e.getValue().size() > 1)
    .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
}

function AllOfTypes findSchemaTypeIntersection(SchemaDefinition def, ParserResult parserResult) {
  boolean first = true;
  boolean allWildcards = true;
  Set<SchemaType> intersection = new HashSet<>();
  Set<SchemaType> union = new HashSet<>();

  for (Schema subSchema : def.getModel().getAllOf()) {
    Set<SchemaType> schemaTypes = ApiFunctions.findPossibleSchemaTypes(subSchema,  parserResult);
    union.addAll(schemaTypes);

    if (schemaTypes.isEmpty()) {
      // No type is found, wildcard
      continue;
    }

    allWildcards = false;

    if (first) {
      intersection.addAll(schemaTypes);
      first = false;
    } else {
      intersection.retainAll(schemaTypes);
    }

    if (intersection.isEmpty()) {
      break;
    }
  }
  boolean valid = allWildcards || !intersection.isEmpty();
  return new AllOfTypes(valid, union);
}

rule "SubSchemas in an allOf should not declare the same properties"
    when
        $schema: SchemaDefinition($model: /model, model.allOf != null)
        $errors: Map(!isEmpty()) from getDoubleProperties($model, parserResult)
    then
        violationAllOfSubSchemasShouldNotDeclareTheSameProperties(oas, $schema, parseErrorStringForDoubleProperties($errors));
end

rule "Discriminator Should Contain Explicit Mapping"
    when
        $schema: SchemaDefinition($discriminator: /model/discriminator)
        Discriminator(mapping == null || mapping.isEmpty()) from $discriminator
    then
        violationDiscriminatorShouldContainMapping(oas, $schema);
end

rule "allOf should not have conflicting types in subschemas"
    when
      $schemaDefinition: SchemaDefinition($schema: /model, model.allOf != null)
      $allOfTypes: AllOfTypes(valid == false) from findSchemaTypeIntersection($schemaDefinition, parserResult)
    then
      violationAllOfSubSchemasShouldNotHaveMultipleTypes(oas, $schemaDefinition, $allOfTypes.getTypes());
end