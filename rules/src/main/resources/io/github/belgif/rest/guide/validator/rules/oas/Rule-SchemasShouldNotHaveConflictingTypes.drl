package io.github.belgif.rest.guide.validator.rules.oas;

import java.util.Set;
import java.util.List;
import java.util.stream.Collectors;
import org.eclipse.microprofile.openapi.models.media.Schema;
import org.eclipse.microprofile.openapi.models.media.Schema.SchemaType;
import io.github.belgif.rest.guide.validator.core.parser.Parser.ParserResult;
global io.github.belgif.rest.guide.validator.core.parser.Parser.ParserResult parserResult;
import io.github.belgif.rest.guide.validator.core.ViolationReport;
global io.github.belgif.rest.guide.validator.core.ViolationReport oas;
import io.github.belgif.rest.guide.validator.core.ApiFunctions;
import io.github.belgif.rest.guide.validator.core.ApiFunctions.ConflictingSchemaValidation;
import io.github.belgif.rest.guide.validator.core.model.SchemaDefinition;

function void violationAllOfSubSchemasShouldNotHaveMultipleTypes(ViolationReport oas, SchemaDefinition schema, ConflictingSchemaValidation confictingSchemaValidation) {
    oas.addViolation("[sch-allof]",
    "Subschemas in an allOf/oneOf/anyOf cannot be of a conflicting type.", "These types are incompatible: <<" + confictingSchemaValidation.getDeclaredTypesString() + ">>", schema);
}

rule "schemas should not have conflicting types in subschemas"
    when
      $schemaDefinition: SchemaDefinition($schema: /model)
      $conflictingSchemaValidation: ConflictingSchemaValidation(hasConflict == true) from ApiFunctions.findSchemaTypes($schema, parserResult)
    then
      violationAllOfSubSchemasShouldNotHaveMultipleTypes(oas, $schemaDefinition, $conflictingSchemaValidation);
end