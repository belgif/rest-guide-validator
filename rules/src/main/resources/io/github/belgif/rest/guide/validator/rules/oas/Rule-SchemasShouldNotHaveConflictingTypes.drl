package io.github.belgif.rest.guide.validator.rules.oas;

import java.util.HashSet;
import java.util.Set;
import java.util.stream.Collectors;
import org.eclipse.microprofile.openapi.models.media.Schema;
import org.eclipse.microprofile.openapi.models.media.Schema.SchemaType;
import io.github.belgif.rest.guide.validator.core.parser.Parser.ParserResult;
global io.github.belgif.rest.guide.validator.core.parser.Parser.ParserResult parserResult;
import io.github.belgif.rest.guide.validator.core.ViolationReport;
global io.github.belgif.rest.guide.validator.core.ViolationReport oas;
import io.github.belgif.rest.guide.validator.core.ApiFunctions;
import io.github.belgif.rest.guide.validator.core.model.SchemaDefinition;


declare SubTypes
    valid : boolean
    types : Set<SchemaType>
end

function void violationAllOfSubSchemasShouldNotHaveMultipleTypes(ViolationReport oas, SchemaDefinition schema, Set<SchemaType> types) {
    String typeOutput = types.stream().map(SchemaType::toString).collect(Collectors.joining(", ")).toString();
    oas.addViolation("[sch-allof]",
    "Subschemas in an allOf/oneOf/anyOf MUST be of the same schemaType.", "Multiple schemaTypes were found: <<" + typeOutput + ">>", schema);
}

//function SubTypes findSchemaTypeIntersection(SchemaDefinition def, ParserResult parserResult) {
//  boolean first = true;
//  boolean allWildcards = true;
//  Set<SchemaType> intersection = new HashSet<>();
//  Set<SchemaType> union = new HashSet<>();
//
//  for (Schema subSchema : def.getModel().getAllOf()) {
//    Set<SchemaType> schemaTypes = ApiFunctions.findPossibleSchemaTypes(subSchema,  parserResult);
//    union.addAll(schemaTypes);
//
//    if (schemaTypes.isEmpty()) {
//      // No type is found, wildcard
//      continue;
//    }
//
//    allWildcards = false;
//
//    if (first) {
//      intersection.addAll(schemaTypes);
//      first = false;
//    } else {
//      intersection.retainAll(schemaTypes);
//    }
//
//    if (intersection.isEmpty()) {
//      break;
//    }
//  }
//  boolean valid = allWildcards || !intersection.isEmpty();
//  return new SubTypes(valid, union);
//}

function SubTypes findSchemaTypeIntersection(SchemaDefinition def, ParserResult parserResult) {
  Set<SchemaType> schemaTypes = ApiFunctions.findPossibleSchemaTypes(def.getModel(), parserResult);
  boolean valid = schemaTypes.isEmpty() || schemaTypes.size() == 1;
  return new SubTypes(valid, schemaTypes);
}

rule "allOf should not have conflicting types in subschemas"
    when
      $schemaDefinition: SchemaDefinition($schema: /model)
      $subTypes: SubTypes(valid == false) from findSchemaTypeIntersection($schemaDefinition, parserResult)
    then
      violationAllOfSubSchemasShouldNotHaveMultipleTypes(oas, $schemaDefinition, $subTypes.getTypes());
end