package io.github.belgif.rest.guide.validator.rules.oas;

import java.util.Set;
import java.util.stream.Collectors;
import org.eclipse.microprofile.openapi.models.media.Schema;
import org.eclipse.microprofile.openapi.models.media.Schema.SchemaType;
import io.github.belgif.rest.guide.validator.core.parser.Parser.ParserResult;
global io.github.belgif.rest.guide.validator.core.parser.Parser.ParserResult parserResult;
import io.github.belgif.rest.guide.validator.core.ViolationReport;
global io.github.belgif.rest.guide.validator.core.ViolationReport oas;
import io.github.belgif.rest.guide.validator.core.ApiFunctions;
import io.github.belgif.rest.guide.validator.core.ApiFunctions.AllowedSchemaTypes;
import io.github.belgif.rest.guide.validator.core.model.SchemaDefinition;

function void violationAllOfSubSchemasShouldNotHaveMultipleTypes(ViolationReport oas, SchemaDefinition schema, Set<SchemaType> types) {
    String typeOutput = types.stream().map(SchemaType::toString).collect(Collectors.joining(", ")).toString();
    oas.addViolation("[sch-allof]",
    "Subschemas in an allOf/oneOf/anyOf cannot be of a conflicting type.", "Multiple types were found: <<" + typeOutput + ">>", schema);
}

rule "schemas should not have conflicting types in subschemas"
    when
      $schemaDefinition: SchemaDefinition($schema: /model)
      $allowedTypes: AllowedSchemaTypes(valid == false) from ApiFunctions.findSchemaTypes($schema, parserResult)
    then
      violationAllOfSubSchemasShouldNotHaveMultipleTypes(oas, $schemaDefinition, $allowedTypes.allDeclaredTypes());
end